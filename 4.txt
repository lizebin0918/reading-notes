    一个类的传统使用方式是允许使用者通过它所提供的公有构造函数来获得实例。有另外一种技术应该成为编程工具的一部分。一个类可以提供一个公共的静态工厂方法，这个静态方法返回该类的实例。这里有一个简单的例子，来自于Boolean，`Boolean.valuOf()`可以把原生类型的boolean变量转换为Boolean引用变量

    不过需要注意的是上文提到的静态工厂方法跟[条款95]所说的工厂方法设计模式不一样。这里的静态工厂方法不是直接等价于设计模式。

    (A class can provide its clients with static factory methods instead of, or in addition to, public constructors)类除了提供静态工厂方法给到使用者，也可以提供公有的构造函数。提供公有的工厂方法而不采用公共构造函数会存在优缺点。

    优点一：静态工厂方法有名字，然而构造函数没有。(If the parameters to a constructor do not, in and of themselves, describe the object being returned, a static factory with a well-chosen name is easier to use and the resulting client code easier to read)如果构造函数的参数以及它本身无法描述返回的对象，静态工厂含有好的名字，有利于函数的使用及调用者阅读。例如，构造函数BigInteger(int, int, Random),返回的BigInteger实例是一个原生类型，采用工厂方法命名为BigInteger.probablePrime，这是更好的表达方式(这个方法在Java4之后添加)

    (A class can have only a single constructor with a given signature.)一个类有且仅有一个单独的有给定的签名的构造函数。(Programmers have been known to get around this restriction by providing two constructors whose parameter lists differ only in the order of their parameter types)程序员可以通过两个构造函数的参数类型不同区分开参数列表的不同知道彼此的约束。这是一个糟糕的注意。API的使用者从不会记住构造函数，最终会调用了错误的构造函数。(People reading code that uses these constructors will not know what the code does without referring to the class documentation)人们阅读使用构造函数的代码，没有在类文档中引用(注释)，将不会知道这段代码是做什么的。因为构造函数有了名称，静态工厂不会遇到上述章节所讨论的限制。如果一个类有多个构造函数都是相同的名字，采用静态工厂方法替换这些构造函数，并细致地通过命名来强调函数之间的区别。

    第二个优点是静态工厂方法不同于构造函数，它们不要求每次执行都要创建一个新的对象。不可变的类使用提前构造的对象或者构造之后把对象缓存起来，重复执行(dispense)避免创建不必要的冗余对象。
   
     `Boolean.valueOf(boolean)`方法就是这种做法的说明，它不会创建一个对象。这种做法类似于`Flyweightpattern`设计模式。(It can greatly improve performance if equivalent objects are requested often, especially if they are expensive to create)如果参数对象都是等价的，特别是创建耗性能的对象，这样做可以最大程度地提供性能。

    (The ability of static factory methods to return the same object from repeated invocations allows classes to maintain strict control over what instances exist at any time)静态工厂方法的作用是重复执行都会返回同一个对象，只是类自身保持严格控制对象在什么时候创建。(Classes that do this are said to be instance-controlled)类的这种行为被称为对象控制（我们常说的委托？）。编写对象控制类有几个理由。对象控制保证一个类是单例的或者不可实例化的。而且
