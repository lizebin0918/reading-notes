# 网络

* 通过arp协助广播，只能在同一网段内广播，可以获得ip地址对应的mac地址，像水波一样散开最终有节点返回对应的mac地址，arp也有缓存的
* 集线器可以连接成一个局域网，但是基于半双工通信，而且没有任何缓存，只要有一根线连着就会广播，非常消耗网络资源，很多无用的包被拒绝，设备越多性能越差
* 交换机是多个网桥的集合，自身可以记住ip和地址，全球的机器不可能都连在同一个局域网，如果广播arp消息，产生广播风暴。还有一个作用是隔绝冲突域
* 路由器+交换机可以实现跨网段，隔绝广播域，实现不同网段之间转发数据。路由器和域内机器都需要配置网关地址
* 每个网卡会有一个6个字节的mac地址
* arp的广播mac地址全部都是1，没有具体的数据，缓存有效期2分钟
* IP地址必须配合子网掩码才知道网段，ip的编号最多只能是1-254。0是表示网段，255表示广播地址。
* 总结abcd类地址概念，a类地址必须为0开头，取值为0-127，b类地址以10开头，网络id取值为128-191，c类以11开头，网络id取值为192-255
* 两个ip是否在同一个网段，大致的判断流程是a机器ip给b机器ip发消息，a的机器会通过自身的子网掩码推算出目标机器的子网掩码，判断是否在同一个网络id
* 数据包的传输过程，ip不会变，但是两端的mac地址会变，不断地寻找广播域内的mac地址转发
* 当我们访问因特网，需要通过nat转换成外网ip，而且不一定是一次转换，而且会导致经常变，这一步是由路由器完成，节约公网ip，现在最常用的是通过端口映射达到多路复用
* 网络分层
    * ISO：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
    * TCP/IP 协议：应用层、传输层、网络层、网络接口层
    * 学习：应用层、传输层、网络层、数据链路层、物理层

## 数据链路层（以太网帧、PPP帧）

* 网络层的目标IP地址（同一网络ID的目标IP，但是最终的目标IP不变），通过ARP协议( Address Resolution Protocol(地址解析协议) )，缓存了对应的目标IP和MAC地址，找到下一跳的MAC地址，修改下一跳的MAC地址
* 以帧的形式传输
* 数据的长度范围：46-1500字节
* 首部：目标MAC + 源MAC + 网络类型 = 12字节
* 以太网帧：首部 + 数据 + FCS（差错校验，4字节）

## 网络层（IP数据包，PACKET）

* 组成：首部（目标IP）、数据，报文单位：包（IP数据包）
* 数据链路层切割了多少块，就会有多少个帧
* 通过目标IP如何找到目标主机？
    * 目标IP与路由表的**子网掩码**匹配，网络ID按位&，找到路由器的网关
    * **路由器会维护自己的路由表，并且维护了不同的网段**，重复上述步骤找到下一跳，不断通过路由器的网关找到下一跳的mac地址（目标是找到mac地址）
    * 每个跳点都会重复上述两步，再到数据链路层
    
## 传输层

* TCP和UDP
    * TCP面向连接的可靠传输协议，报文单位：段
    * UDP面向无连接的传输协议

* TCP报文头
    * 源端口、目标端口
    * **序号**：sequence，四个字节，在传输过程的每一个字节都会有一个编号。在建立连接后，序号代表：这一次传给对方的TCP数据部分的第一个字节的编号（因为数据是分一段字节传输的，这个序号就填分段后，首字节编号）
    * **确认号**： ack，四个字节，建立连接后，确认号表示：期望对方下一次传过来的TCP数据部分的第一个字节的编号（滑动窗口用到）
    * 数据偏移、保留、6个标记位、收发窗口大小
    * URG=1:紧急指针才有效，表明当前报文段中有紧急数据，应优先尽快传送
    * ACK=1:确认号的字段才有意义
    * PSH
    * RST=1:表明连接中出现严重差错，必须释放连接，然后再重新建立连接
    * SYN=1,ACK=0:表明这是一个建立连接的请求，如果对方同意建立连接，SYN=ACK=1
    * FIN=1:数据发送完毕，可以释放连接
    
* 监听端口的最大连接数
    * 65535这个数字，只是决定了服务器端最多可以拥有65535个Bind的Socket。也就是说，最多可以开65535个服务器进程，但是你要知道这个能够连接客户端的数量没有任何关系，Accept过来的Socket是不需要Bind任何IP地址的，也没有端口占用这一说。作为Server端的Socket本身只负责监听和接受连接操作。
    * TCP协议里面是用[源IP+源Port+目的IP+目的 Port]（四元组）来区别不同连接，所以连入和连出是两个不同的概念。连出Connect就不错了，需要生成随机端口，这个是有限的连入的话， 因SOCKET的分配受内存分页限制，而连接受限制（WINDOWS）。
    * 所以，千万不要误以为1个server只允许连接65535个Client。记住，TCP连出受端口限制,连入仅受内存限制。
    * socket套接字定义（四元组）：clientIP/clientPort-->serverIP/serverPort，每次TCP连接都会开辟一个socket的内存空间通讯，而不是通过端口来通讯，客户端和服务端的通信其实是基于双方的一小块内存实现的

* 三次握手
    * 为什么是3次而不是两次？**最终是要互相保证客户端和服务端的输入和输出，保证可靠的全双工通信**
        * Client发送SYN=1，ACK=0，seq=x，ack=0给Server(实际客户端序号初始值（比较大，不是从1开始），用于后续发送数据包的序号=seq+1)，Server知道自己的输入没问题
        * Server发送SYN=1，ACK=1，seq=y，ack=x+1(表示收到客户端的包)给Client：Client知道自己的输入输出都没问题(实际服务端序号初始值（比较大，不是从1开始），用于后续发送数据包的序号=seq+1)
        * Client发送SYN=0，ACK=1，seq=x+1，ack=y+1给Server：保证了Server端知道自己的输出没问题
    
* 四次挥手
    * 为什么是四次而不是2次？因为tip/ip是全双工通讯传输。客户端发送fin结束通讯，表示发送完毕；服务端收到并确认客户端不再发送消息。而服务端假如此时消息并没发送完。就结束双方通讯，那么tcp、ip就会变得不可靠。所以服务端也要发送一次fin消息结束通讯。客户端ack确认结束，此时全双工通讯正式结束
    
    > 第一次：Client关闭数据输出
    > 第二次：Server收到FIN，发完最后的数据（这一步不一定有，Server端没数据返回，就没必要发送这一个报文了）
    > 第三次：Server关闭数据输出
    > 第四次：Client确认关闭输入、Server端收到也关闭输入
    
    * client发送ACK后，需要有一个TIME-WAIT阶段，等待一段时间后才会关闭连接，一般是等待2倍的MSL（最大分段生存期-MSL） ，MSL是TCP报文在Internet上的最长生存时间，一般是2分钟
    * 如果接收方没有收到第四次的ACK，会重发FIN，如果没有TIME-WAIT，那接收方就会一直发FIN，导致资源浪费。万一client有一个新的程序连接，分配一个相同的端口号，这个时候收到重试的FIN后，马上断开连接，导致连接有误。一句话概括：TIME_WAIT存在的意义，防止本次产生的数据包误传到下一次连接中（因为本次连接中的数据包都会在2MSL时间内消失）
    * tcpdump抓包:tcpdump host 10.0.0.15
    
* 可靠传输
    * 数据分为三个部分（窗口从左到右）：已发送并确认、已发送未确认、待发送
    * 连续ARQ协议+滑动窗口rwnd（在三次握手的时候告知，可动态调整）
    * SACK（Selective Acknowledgment）:选择性确认，比如发送1,2,3,4,5，3丢失了，如果没有SACK，最后确认的是2，3,4,5需要重传，降低了TCP性能。SACK能告诉发送方丢失的包，最大占用字节数 = 4 * 8 + 2 = 34
 
* 流量控制
    * 定义：让发送方的发送速率不要太快，让接收方来得及接收处理，面向端对端的
    
    * 原理
    
    > 通过确认报文中窗口字段来控制发送方的发送速率
    > 发送方的发送窗口大小不能超过接收方给出窗口的大小
    > 当发送方接收到接收窗口为0时，发送方会停止发送数据。并且启动一个定时器，隔一段时间就发送一个测试报文去询问接收方最新的窗口大小

* 拥塞控制
    * 定义
    
    > 防止过多的数据注入到网络中
    > 避免网络中的路由器或者链路过载
    > 拥塞控制是一个全局性的过程
    > MSS(Max Segment Size):每个段最大的数据部分大小=1500-网络层头部字节（20个字节）- 传输层头部字节（20个字节）= 1460
    > cwnd:拥塞窗口，发送方感知网络状况调整窗口大小
    > rwnd:接收窗口
    > swnd:发送窗口
    
    * 原理
    
    > 慢开始：每次发1、2、4、8个包，指数递增，达到阈值之后线性增加
    > 拥塞避免：发生网络拥塞（丢包，超时未回应），乘法减小，重新慢开始，再加法增大
    > 快速重传：每收到一个失序的分组后立即发出重复确认（旧版）
    > 快速恢复：快重传（收到3个重复的确认）+快恢复（在新的阈值下加法增大）
    
* 常见问题
    * 如果有个包重传了N次还是失败，会一直持续重传直到成功么？
    
    > 取决于操作系统，如果重传达到一定错误次数，需要发送RST包，断开连接重连，TCP的头部可以设置RST=1
    
    * 接口窗口一直不满怎么办？
    
    > 等待一定时间后，会告诉上次连续接收的最后一个字节的位置，让客户端重发后面的字节
    
    * 为什么选择在传输层分割？
    
    > 每一层各司其职，网络层只能接受MTU大小的报文，而且不能保证可靠和重传

## 应用层

* DNS:Domain Name System:域名系统，当我们再浏览器访问域名，需要请求DNS服务器（端口53，可基于UDP或者TCP）
* www.baidu.com
    * com:顶级域名
    * baidu:二级域名   
    * 经历多个DNS服务器：根名称服务器、com顶级名称服务器、二级域名服务器（baidu.com），权威名称服务器
    * 上级DNS服务器记录了下级DNS服务器
    * 全球一共13台IPV4的根域名服务器，25台IPV6
* DHCP:Dynamic Host Configuration Protocol:动态主机配置协议，基于UDP协议，客户端是68端口，的服务器是67端口
* ABNF:描述HTTP的报文格式，具体实现需要根据HTTP服务器来定

    > start-line //请求或者响应的开始行 request-line / statue-line:Get /XXXX/XX/ HTTP/1.1
    > *( header-field CRLF ) //星号表示0个或者多个，一个header-field换行
    > CRLF
    > [ message-body ]
* `header-field=field-name ":" OWS field-value OWS`
    > field-name = token
    > field-value = *(field-content / obs-fold)
    > OWS = *(SP / HTAP) `一个或多个空格、TAB`
    > 可以通过telnet来检验报文正确与否
* 九种方法作用

    * GET:
    * POST
        * enctype:post请求时，请求体的编码方式，application/x-www-form-urlencoded（默认值）用&分隔参数，用=表示键值，字符用URL编码
        * 文件上传必须采用：multipart/form-data
    * HEAD:下载一个大文件前，先获取大小，再决定是否要下载。测试超链接的有效性，是否可以访问，以及最近是否更新。
    * OPTIONS:服务器支持的方法
    * CONNECT:可以开启一个客户单与所请求资源之间的双向沟通通道，用来创建隧道，用来访问采用了SSL(https)协议的站点

* header作用
    * 请求头字段
    
        * User-Agent:浏览器标识字段
        * Host:服务器域名、端口号-localhost:80
        * **Origin**:发起一个针对跨域资源共享的请求
            * 浏览器有同源策略（Same-Origin Policy），规定了默认情况下，Ajax请求只能发送给同源的URL，同源是指3个相同：协议、域名、端口（img/script/link/iframe/video/audio等标签不受同源策略的约束）
            * CORS（Cross-Origin Resource Sharding）：跨域资源共享
        * **Cookie**:由服务端通过set-cookie发送的cookie，里面还包含domain、path表示对于的域
        * **Cache-Control**:用来指定在这次请求、响应的所有缓存机制都必须遵守的指令
            * no-storage:不缓存到本地
            * public:允许用户、代理服务器缓存数据到本地
            * private:只允许用户缓存数据到本地
            * max-age:缓存的有效时间（多长时间不过期），单位：秒
            * no-cache:每次需要发请求给服务器询问缓存是否有变化，再来决定如何使用缓存
        * Referer:表示浏览器访问的前一个页面。访问图片是通过其他网站过来的，屏蔽掉
        * Connection:keep-alive-不要马上断开连接
        * Range:仅请求某个实体的一部分，字节偏移以0开始-用于断点下载
        
    * 响应头字段
        * content-type
        * content-disposition:客户端下载文件并建议文件名的头部
    
## 正向代理、反向代理
  * 正向代理，其实是"代理服务器"代理了"客户端"，去和"目标服务器"进行交互，例如翻墙。服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端
  * 反向代理（reverse proxy）：反向代理，其实是"代理服务器"代理了"目标服务器"，去和"客户端"进行交互。客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器。
  * 思考：nginx反向代理转发请求到Server，最终的tcp连接是：nginx.ip:port-->server.ip:port，为什么不是客户端的实际ip:port?
      * 请求头会添加对应字段
       
        > Via:追加经过的每一台代理服务器的主机名（或域名）
        > X-Forwarded-For:追加请求方的IP地址
        > X-Real-IP:客户端的真实IP地址
        
## 安全相关
* 带宽消耗型：UDP洪水攻击、ICMP洪水攻击（PING请求）  
* 资源消耗型：SYN洪水攻击、LAND攻击
* DNS劫持：域名解析其他IP
* HTTP劫持：对HTTP数据包进行拦截处理，比如插入JS代码

##HTTPS
* 数字签名：确认消息的完整性，实际就是非对称加密反过来使用
* 公钥：公钥加密，私钥可以解密（非对称加密-公钥加密）
* 私钥：私钥加密，公钥也可以解密（数字签名-私钥加密，公钥验签）
* 中间人攻击，伪造公钥，作为客户端和服务端通讯的“桥梁”，窃取或者篡改数据
    
    > 通过CA机构来保证server公钥的安全性，各大CA的公钥，默认已经内痔在浏览器和操作系统中
    > server到CA注册自己的公钥，生成数字证书，包括CA用私钥添加数字签名、server的公钥
    > client拿到数字证书，采用CA的公钥验签，解密拿到server端的公钥
    
##HTTPS如何保证安全
* HTTPS:HTTP over TLS、HTTP over SSL、HTTP Secure
* 默认端口是443，以前是SSL，后续升级TLS-传输层安全性协议，**工作在HTTP和TCP/IP层之间**
* OpenSSL是SSL/TLS的开源实现
* 通讯过程
    * TCP的3次握手
    * TLS的连接
    * HTTP请求和响应
* TLS（Transport Layer Security）握手协议
    * client hello:TLS的版本号、支持的加密组件、随机数
    * server hello:TLS的版本号、选择的加密组件、随机数（不是客户端的随机数）
    * server send Certificate:被CA校验过的证书
    * server key exchange:用以实现ECDHE的算法的一个参数-server params
    * server hello done:协商部分结束
    * 以上五步是明文传输，客户端也会请求CA验签，拿到server的公钥
    * client key exchange:用以实现ECDHE算法的另一个参数-client params，生成一个新的随机密钥串-pre-master secret，利用三个params生成**会话密钥**
    * change cipher spece:告知服务器，之后的通信都采用会话密钥进行加密通讯，这个只是通知包
    * finish:连接至今全部报文的整体校验值（摘要），加密之后发送给服务器
    * （server）change cipher spec、Finish:客户端服务器都验证加密解密没问题，握手正式结束
     
    
    


