# 网络

* 通过arp协助广播，只能在同一网段内广播，可以获得ip地址对应的mac地址，像水波一样散开最终有节点返回对应的mac地址，arp也有缓存的
* 集线器可以连接成一个局域网，但是基于半双工通信，而且没有任何缓存，只要有一根线连着就会广播，非常消耗网络资源，很多无用的包被拒绝，设备越多性能越差
* 交换机是多个网桥的集合，自身可以记住ip和地址，全球的机器不可能都连在同一个局域网，如果广播arp消息，产生广播风暴。还有一个作用是隔绝冲突域
* 路由器+交换机可以实现跨网段，隔绝广播域，实现不同网段之间转发数据。路由器和域内机器都需要配置网关地址
* 每个网卡会有一个6个字节的mac地址
* arp的广播mac地址全部都是1，没有具体的数据，缓存有效期2分钟
* IP地址必须配合子网掩码才知道网段，ip的编号最多只能是1-254。0是表示网段，255表示广播地址。
* 总结abcd类地址概念，a类地址必须为0开头，取值为0-127，b类地址以10开头，网络id取值为128-191，c类以11开头，网络id取值为192-255
* 两个ip是否在同一个网段，大致的判断流程是a机器ip给b机器ip发消息，a的机器会通过自身的子网掩码推算出目标机器的子网掩码，判断是否在同一个网络id
* 数据包的传输过程，ip不会变，但是两端的mac地址会变，不断地寻找广播域内的mac地址转发
* 当我们访问因特网，需要通过nat转换成外网ip，而且不一定是一次转换，而且会导致经常变，这一步是由路由器完成，节约公网ip，现在最常用的是通过端口映射达到多路复用
* 网络分层
    * ISO：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
    * TCP/IP 协议：应用层、传输层、网络层、网络接口层
    * 学习：应用层、传输层、网络层、数据链路层、物理层

## 数据链路层（以太网帧、PPP帧）

* 网络层的目标IP地址（同一网络ID的目标IP，但是最终的目标IP不变），通过ARP协议，缓存了对应的目标IP和MAC地址，找到下一跳的MAC地址，修改下一跳的MAC地址
* 以帧的形式传输
* 数据的长度范围：46-1500字节
* 首部：目标MAC + 源MAC + 网络类型 = 12字节
* 以太网帧：首部 + 数据 + FCS（差错校验，4字节）

## 网络层（IP数据包，PACKET）

* 组成：首部（目标IP）、数据，报文单位：包（IP数据包）
* 数据链路层切割了多少块，就会有多少个帧
* 通过目标IP如何找到目标主机？
    * 目标IP与路由表的多个子网掩码匹配，网络ID按位&，找到路由器的网关
    * 路由器会维护自己的路由表，重复上述步骤找到下一跳
    * 每个跳点都会重复上述两步，再到网络层
    
## 传输层

* TCP和UDP
    * TCP面向连接的可靠传输协议，报文单位：段
    * UDP面向无连接的传输协议

* TCP报文头
    * 源端口、目标端口
    * **序号**：sequence，四个字节，在传输过程的每一个字节都会有一个编号。在建立连接后，序号代表：这一次传给对方的TCP数据部分的第一个字节的编号（因为数据是分一段字节传输的，这个序号就填分段后，首字节编号）
    * **确认号**： ack，四个字节，建立连接后，确认号表示：期望对方下一次传过来的TCP数据部分的第一个字节的编号（滑动窗口用到）
    * 数据偏移、保留、6个标记位、收发窗口大小
    * URG=1:紧急指针才有效，表明当前报文段中有紧急数据，应优先尽快传送
    * ACK=1:确认号的字段才有意义
    * PSH
    * RST=1:表明连接中出现严重差错，必须释放连接，然后再重新建立连接
    * SYN=1,ACK=0:表明这是一个建立连接的请求，如果对方同意建立连接，SYN=ACK=1
    * FIN=1:数据发送完毕，可以释放连接
    
* 监听端口的最大连接数
    * 65535这个数字，只是决定了服务器端最多可以拥有65535个Bind的Socket。也就是说，最多可以开65535个服务器进程，但是你要知道这个能够连接客户端的数量没有任何关系，Accept过来的Socket是不需要Bind任何IP地址的，也没有端口占用这一说。作为Server端的Socket本身只负责监听和接受连接操作。
    * TCP协议里面是用[源IP+源Port+目的IP+目的 Port]（四元组）来区别不同连接，所以连入和连出是两个不同的概念。连出Connect就不错了，需要生成随机端口，这个是有限的连入的话， 因SOCKET的分配受内存分页限制，而连接受限制（WINDOWS）。
    * 所以，千万不要误以为1个server只允许连接65535个Client。记住，TCP连出受端口限制,连入仅受内存限制。
    * socket套接字定义（四元组）：clientIP/clientPort-->serverIP/serverPort，每次TCP连接都会开辟一个socket的内存空间通讯，而不是通过端口来通讯，客户端和服务端的通信其实是基于双方的一小块内存实现的

* 三次握手
    * 为什么是3次而不是两次？**最终是要互相保证客户端和服务端的输入和输出**
        * Client发送SYN=1，ACK=0，seq=x，ack=0给Server(实际客户端序号初始值（比较大，不是从1开始），用于后续发送数据包的序号=seq+1)
        * Server发送SYN=1，ACK=1，seq=y，ack=x+1(表示收到客户端的包)给Client：保证了Server的输入，Client的输出都没问题(实际服务端序号初始值（比较大，不是从1开始），用于后续发送数据包的序号=seq+1)
        * Client发送SYN=0，ACK=1，seq=x+1，ack=y+1给Server：保证了Server的输出，Client的输入都没问题
    
* 四次挥手
    
    
* 可靠传输
    * 数据分为三个部分（窗口从左到右）：已发送并确认、已发送未确认、待发送
    * 连续ARQ协议+滑动窗口rwnd（在三次握手的时候告知，可动态调整）
    * SACK（Selective Acknowledgment）:选择性确认，比如发送1,2,3,4,5，3丢失了，如果没有SACK，最后确认的是2，3,4,5需要重传，降低了TCP性能。SACK能告诉发送方丢失的包，最大占用字节数 = 4 * 8 + 2 = 34
 
* 流量控制
    * 定义：让发送方的发送速率不要太快，让接收方来得及接收处理，面向端对端的
    * 原理
    > 通过确认报文中窗口字段来控制发送方的发送速率
    > 发送方的发送窗口大小不能超过接收方给出窗口的大小
    > 当发送方接收到接收窗口为0时，发送方会停止发送数据。并且启动一个定时器，隔一段时间就发送一个测试报文去询问接收方最新的窗口大小

* 拥塞控制
    * 定义
    > 防止过多的数据注入到网络中
    > 避免网络中的路由器或者链路过载
    > 拥塞控制是一个全局性的过程
    > MSS(Max Segment Size):每个段最大的数据部分大小=1500-网络层头部字节（20个字节）- 传输层头部字节（20个字节）= 1460
    > cwnd:拥塞窗口，发送方感知网络状况调整窗口大小
    > rwnd:接收窗口
    > swnd:发送窗口
    * 原理
    > 慢开始：每次发1、2、4、8个包，指数递增，达到阈值之后线性增加
    > 拥塞避免：发生网络拥塞（丢包，超时未回应），乘法减小，重新慢开始，再加法增大
    > 快速重传：每收到一个失序的分组后立即发出重复确认（旧版）
    > 快速恢复：快重传（收到3个重复的确认）+快恢复（在新的阈值下加法增大）
    
* 常见问题
    * 如果有个包重传了N次还是失败，会一直持续重传直到成功么？
    > 取决于操作系统，如果重传达到一定错误次数，需要发送RST包，断开连接重连，TCP的头部可以设置RST=1
    * 接口窗口一直不满怎么办？
    > 等待一定时间后，会告诉上次连续接收的最后一个字节的位置，让客户端重发后面的字节
    * 为什么选择在传输层分割？
    > 每一层各司其职，网络层只能接受MTU大小的报文，而且不能保证可靠和重传

